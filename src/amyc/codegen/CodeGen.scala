package amyc
package codegen

import analyzer._
import ast.Identifier
import ast.SymbolicTreeModule.{Call => AmyCall, Div => AmyDiv, And => AmyAnd, Or => AmyOr, _}
import utils.{Context, Pipeline}
import wasm._
import Instructions._
import Utils._


// Generates WebAssembly code for an Amy program
object CodeGen extends Pipeline[(Program, SymbolTable), Module] {
  def run(ctx: Context)(v: (Program, SymbolTable)): Module = {
    val (program, table) = v

    // Generate code for an Amy module
    def cgModule(moduleDef: ModuleDef): List[Function] = {
      val ModuleDef(name, defs, optExpr) = moduleDef
      // Generate code for all functions
      defs.collect { case fd: FunDef if !builtInFunctions(fullName(name, fd.name)) =>
        cgFunction(fd, name, false)
      } ++
      // Generate code for the "main" function, which contains the module expression
      optExpr.toList.map { expr =>
        val mainFd = FunDef(Identifier.fresh("main"), Nil, TypeTree(IntType), expr)
        cgFunction(mainFd, name, true)
      }
    }

    // Generate code for a function in module 'owner'
    def cgFunction(fd: FunDef, owner: Identifier, isMain: Boolean): Function = {
      // Note: We create the wasm function name from a combination of
      // module and function name, since we put everything in the same wasm module.
      val name = fullName(owner, fd.name)
      Function(name, fd.params.size, isMain){ lh =>
        val locals = fd.paramNames.zipWithIndex.toMap
        val body = cgExpr(fd.body)(locals, lh)
        if (isMain) {
          body <:> Drop // Main functions do not return a value,
                        // so we need to drop the value generated by their body
        } else {
          body
        }
      }
    }

    // Generate code for an expression expr.
    // Additional arguments are a mapping from identifiers (parameters and variables) to
    // their index in the wasm local variables, and a LocalsHandler which will generate
    // fresh local slots as required.
    def cgExpr(expr: Expr)(implicit locals: Map[Identifier, Int], lh: LocalsHandler): Code = expr match {
      case Variable(name) => locals.get(name) match {
        case Some(index) => GetLocal(index)
      }

      // Literals
      case IntLiteral(i) => Const(i)
      case BooleanLiteral(b) => if (b) Const(1) else Const(0)
      case StringLiteral(s) => mkString(s)
      case UnitLiteral() => Const(0) // QUESTION is this valid

      // Binary operators
      case Plus(lhs, rhs) => cgExpr(lhs) <:> cgExpr(rhs) <:> Add
      case Minus(lhs, rhs) => cgExpr(lhs) <:> cgExpr(rhs) <:> Sub
      case Times(lhs, rhs) => cgExpr(lhs) <:> cgExpr(rhs) <:> Mul
      case AmyDiv(lhs, rhs) => cgExpr(lhs) <:> cgExpr(rhs) <:> Div
      case Mod(lhs, rhs) => cgExpr(lhs) <:> cgExpr(rhs) <:> Rem
      case LessThan(lhs, rhs) => cgExpr(lhs) <:> cgExpr(rhs) <:> Lt_s
      case LessEquals(lhs, rhs) => cgExpr(lhs) <:> cgExpr(rhs) <:> Le_s
      case AmyAnd(lhs, rhs) => cgExpr(lhs) <:> cgExpr(rhs) <:> And
      case AmyOr(lhs, rhs) => cgExpr(lhs) <:> cgExpr(rhs) <:> Or
      case Equals(lhs, rhs) => cgExpr(lhs) <:> cgExpr(rhs) <:> Eq // CHECK

      case Concat(lhs, rhs) => cgExpr(lhs) <:> cgExpr(rhs) <:> Call("String_concat")


      case Not(e) => cgExpr(e) <:> Eqz
      case Neg(e) => Const(0) <:> cgExpr(e) <:> Sub
      case AmyCall(qname, args) => {
        val cgFunctionBehavior =
          (table.getConstructor(qname), table.getFunction(qname)) match {
            // case (Some(constrSig), _) => {

            //   val setFields =
            //     cs2c(args.reverse.map(cgExpr)) <:>
            //     cs2c(
            //       (1 to args.length)
            //         .map(
            //           (index: Int) =>
            //             GetGlobal(memoryBoundary) <:> Const(index) <:> Add <:>
            //             Store
            //         )
            //         .toList
            //     )

            //   val setMemory =
            //     GetGlobal(memoryBoundary) <:>
            //       GetGlobal(memoryBoundary) <:> Const((args.length + 1) * 4) <:> Add <:>
            //       SetGlobal(memoryBoundary)

            //   setFields <:> setMemory
            // }
            case (_, Some(funcSig)) => Call(fullName(funcSig.owner, qname))
          }
        cs2c(args.map(cgExpr(_))) <:> cgFunctionBehavior
      }

      case Sequence(e1, e2) => cgExpr(e1) <:> Drop <:> cgExpr(e2)
      case Let(df, value, body) => {
        val newLocalIndex = lh.getFreshLocal()
        cgExpr(value) <:> SetLocal(newLocalIndex) <:> cgExpr(body)(
          locals ++ Map(df.name -> newLocalIndex),
          lh
        )
      }
      case Ite(cond, thenn, elze) =>
        cgExpr(cond) <:>
          If_i32 <:> cgExpr(thenn) <:>
          Else <:> cgExpr(elze) <:>
          End

      // case Match(scrut, cases) =>
      case Match(scrut, cases) => {
        def cgCase(cse: MatchCase): Code = {
          val (cgCondition, cgLocals, moreLocals) = cgPattern(cse.pat)
          cgCondition <:>
          If_i32 <:>
          cgLocals <:> cgExpr(cse.expr)(locals ++ moreLocals, lh) <:>
          Else
        }

        // CodeGeneration For a condition
        def cgPattern(p: Pattern): (Code, Code, Map[Identifier, Int]) = p match {
          case WildcardPattern() => (is2c(Nil), is2c(Nil), Map())
          case IdPattern(name) => {
            val newLocalIndex = lh.getFreshLocal()
            (
              is2c(Nil),
              SetLocal(newLocalIndex),
              Map(name -> newLocalIndex)
            )
          }
          case LiteralPattern(lit) => (
            cgExpr(lit) <:> Eq,
            is2c(Nil),
            Map()
          )
          case CaseClassPattern(constr, args) => {
            val tempLocal = lh.getFreshLocal()

            val condition = SetLocal(tempLocal) <:> GetLocal(tempLocal)
            Load <:> Const(0) <:> Eq <:> // Type id
            args.zipWithIndex.map{
              case (arg, i) =>
              GetLocal(tempLocal) <:>
              adtField(i) <:> Load <:>
              cgPattern(arg)._2
            }

            val localsGeneration = args.zipWithIndex.map{
              case (arg, i) =>
                GetLocal(tempLocal) <:>
                adtField(i) <:> Load <:>
                cgPattern(arg)._1
            }

            val newEnv = args.map(cgPattern)
              .foldLeft(Map[Identifier, Int]())(
                (
                  acc: Map[Identifier, Int],
                  patResults: (Code, Code, Map[Identifier, Int])
                ) => acc ++ patResults._3
              )
            (condition, localsGeneration, newEnv)
          }
        }

        cgExpr(scrut) <:> cases.map(cgCase) <:> Unreachable <:> End
      }
      case Error(msg) => cgExpr(msg) <:> Unreachable

    }

    Module(
      program.modules.last.name.name,
      defaultImports,
      globalsNo,
      wasmFunctions ++ (program.modules flatMap cgModule)
    )

  }
}
